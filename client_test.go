/*
 * dotcom-monitor
 *
 * dotcom-monitor API
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package dotcommonitor

import (
	"bytes"
	"context"
	"mime/multipart"
	"net/http"
	"net/url"
	"reflect"
	"testing"
	"time"
)

func TestNewAPIClient(t *testing.T) {
	type args struct {
		cfg *Configuration
	}
	tests := []struct {
		name string
		args args
		want *APIClient
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewAPIClient(tt.args.cfg); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewAPIClient() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_atoi(t *testing.T) {
	type args struct {
		in string
	}
	tests := []struct {
		name    string
		args    args
		want    int
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := atoi(tt.args.in)
			if (err != nil) != tt.wantErr {
				t.Errorf("atoi() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("atoi() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_selectHeaderContentType(t *testing.T) {
	type args struct {
		contentTypes []string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := selectHeaderContentType(tt.args.contentTypes); got != tt.want {
				t.Errorf("selectHeaderContentType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_selectHeaderAccept(t *testing.T) {
	type args struct {
		accepts []string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := selectHeaderAccept(tt.args.accepts); got != tt.want {
				t.Errorf("selectHeaderAccept() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_contains(t *testing.T) {
	type args struct {
		haystack []string
		needle   string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := contains(tt.args.haystack, tt.args.needle); got != tt.want {
				t.Errorf("contains() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_typeCheckParameter(t *testing.T) {
	type args struct {
		obj      interface{}
		expected string
		name     string
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := typeCheckParameter(tt.args.obj, tt.args.expected, tt.args.name); (err != nil) != tt.wantErr {
				t.Errorf("typeCheckParameter() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_parameterToString(t *testing.T) {
	type args struct {
		obj              interface{}
		collectionFormat string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := parameterToString(tt.args.obj, tt.args.collectionFormat); got != tt.want {
				t.Errorf("parameterToString() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestAPIClient_callAPI(t *testing.T) {
	type fields struct {
		cfg          *Configuration
		common       service
		DeviceApi    *DeviceApiService
		PlatformsApi *PlatformsApiService
		TaskApi      *TaskApiService
		LoginApi     *LoginApiService
	}
	type args struct {
		request *http.Request
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    *http.Response
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &APIClient{
				cfg:          tt.fields.cfg,
				common:       tt.fields.common,
				DeviceApi:    tt.fields.DeviceApi,
				PlatformsApi: tt.fields.PlatformsApi,
				TaskApi:      tt.fields.TaskApi,
				LoginApi:     tt.fields.LoginApi,
			}
			got, err := c.callAPI(tt.args.request)
			if (err != nil) != tt.wantErr {
				t.Errorf("APIClient.callAPI() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("APIClient.callAPI() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestAPIClient_ChangeBasePath(t *testing.T) {
	type fields struct {
		cfg          *Configuration
		common       service
		DeviceApi    *DeviceApiService
		PlatformsApi *PlatformsApiService
		TaskApi      *TaskApiService
		LoginApi     *LoginApiService
	}
	type args struct {
		path string
	}
	tests := []struct {
		name   string
		fields fields
		args   args
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &APIClient{
				cfg:          tt.fields.cfg,
				common:       tt.fields.common,
				DeviceApi:    tt.fields.DeviceApi,
				PlatformsApi: tt.fields.PlatformsApi,
				TaskApi:      tt.fields.TaskApi,
				LoginApi:     tt.fields.LoginApi,
			}
			c.ChangeBasePath(tt.args.path)
		})
	}
}

func TestAPIClient_prepareRequest(t *testing.T) {
	type fields struct {
		cfg          *Configuration
		common       service
		DeviceApi    *DeviceApiService
		PlatformsApi *PlatformsApiService
		TaskApi      *TaskApiService
		LoginApi     *LoginApiService
	}
	type args struct {
		ctx          context.Context
		path         string
		method       string
		postBody     interface{}
		headerParams map[string]string
		queryParams  url.Values
		formParams   url.Values
		fileName     string
		fileBytes    []byte
	}
	tests := []struct {
		name                string
		fields              fields
		args                args
		wantLocalVarRequest *http.Request
		wantErr             bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &APIClient{
				cfg:          tt.fields.cfg,
				common:       tt.fields.common,
				DeviceApi:    tt.fields.DeviceApi,
				PlatformsApi: tt.fields.PlatformsApi,
				TaskApi:      tt.fields.TaskApi,
				LoginApi:     tt.fields.LoginApi,
			}
			gotLocalVarRequest, err := c.prepareRequest(tt.args.ctx, tt.args.path, tt.args.method, tt.args.postBody, tt.args.headerParams, tt.args.queryParams, tt.args.formParams, tt.args.fileName, tt.args.fileBytes)
			if (err != nil) != tt.wantErr {
				t.Errorf("APIClient.prepareRequest() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(gotLocalVarRequest, tt.wantLocalVarRequest) {
				t.Errorf("APIClient.prepareRequest() = %v, want %v", gotLocalVarRequest, tt.wantLocalVarRequest)
			}
		})
	}
}

func TestAPIClient_decode(t *testing.T) {
	type fields struct {
		cfg          *Configuration
		common       service
		DeviceApi    *DeviceApiService
		PlatformsApi *PlatformsApiService
		TaskApi      *TaskApiService
		LoginApi     *LoginApiService
	}
	type args struct {
		v           interface{}
		b           []byte
		contentType string
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &APIClient{
				cfg:          tt.fields.cfg,
				common:       tt.fields.common,
				DeviceApi:    tt.fields.DeviceApi,
				PlatformsApi: tt.fields.PlatformsApi,
				TaskApi:      tt.fields.TaskApi,
				LoginApi:     tt.fields.LoginApi,
			}
			if err := c.decode(tt.args.v, tt.args.b, tt.args.contentType); (err != nil) != tt.wantErr {
				t.Errorf("APIClient.decode() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_addFile(t *testing.T) {
	type args struct {
		w         *multipart.Writer
		fieldName string
		path      string
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := addFile(tt.args.w, tt.args.fieldName, tt.args.path); (err != nil) != tt.wantErr {
				t.Errorf("addFile() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_reportError(t *testing.T) {
	type args struct {
		format string
		a      []interface{}
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := reportError(tt.args.format, tt.args.a...); (err != nil) != tt.wantErr {
				t.Errorf("reportError() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_setBody(t *testing.T) {
	type args struct {
		body        interface{}
		contentType string
	}
	tests := []struct {
		name        string
		args        args
		wantBodyBuf *bytes.Buffer
		wantErr     bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotBodyBuf, err := setBody(tt.args.body, tt.args.contentType)
			if (err != nil) != tt.wantErr {
				t.Errorf("setBody() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(gotBodyBuf, tt.wantBodyBuf) {
				t.Errorf("setBody() = %v, want %v", gotBodyBuf, tt.wantBodyBuf)
			}
		})
	}
}

func Test_detectContentType(t *testing.T) {
	type args struct {
		body interface{}
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := detectContentType(tt.args.body); got != tt.want {
				t.Errorf("detectContentType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_parseCacheControl(t *testing.T) {
	type args struct {
		headers http.Header
	}
	tests := []struct {
		name string
		args args
		want cacheControl
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := parseCacheControl(tt.args.headers); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("parseCacheControl() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestCacheExpires(t *testing.T) {
	type args struct {
		r *http.Response
	}
	tests := []struct {
		name string
		args args
		want time.Time
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := CacheExpires(tt.args.r); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("CacheExpires() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_strlen(t *testing.T) {
	type args struct {
		s string
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := strlen(tt.args.s); got != tt.want {
				t.Errorf("strlen() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGenericSwaggerError_Error(t *testing.T) {
	type fields struct {
		body  []byte
		error string
		model interface{}
	}
	tests := []struct {
		name   string
		fields fields
		want   string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := GenericSwaggerError{
				body:  tt.fields.body,
				error: tt.fields.error,
				model: tt.fields.model,
			}
			if got := e.Error(); got != tt.want {
				t.Errorf("GenericSwaggerError.Error() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGenericSwaggerError_Body(t *testing.T) {
	type fields struct {
		body  []byte
		error string
		model interface{}
	}
	tests := []struct {
		name   string
		fields fields
		want   []byte
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := GenericSwaggerError{
				body:  tt.fields.body,
				error: tt.fields.error,
				model: tt.fields.model,
			}
			if got := e.Body(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("GenericSwaggerError.Body() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGenericSwaggerError_Model(t *testing.T) {
	type fields struct {
		body  []byte
		error string
		model interface{}
	}
	tests := []struct {
		name   string
		fields fields
		want   interface{}
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := GenericSwaggerError{
				body:  tt.fields.body,
				error: tt.fields.error,
				model: tt.fields.model,
			}
			if got := e.Model(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("GenericSwaggerError.Model() = %v, want %v", got, tt.want)
			}
		})
	}
}
